Example..Steps


Create an Initial File and Commit, Create a file called app.js and add some code:
echo 'console.log("Hello from main branch");' > app.js
Add and commit this file:
git add app.js
git commit -m "Initial commit with app.js"
Now we have a main branch with one file.
Create and Switch to a New Branch, Create a new branch feature-branch and switch to it:
git checkout -b feature-branch
Modify app.js:
echo 'console.log("Hello from feature branch");' > app.js
Stage and commit the changes:
git add app.js
git commit -m "Updated app.js in feature-branch"
Now, we have different versions of app.js in main and feature-branch.









Switch Back to Main and Modify the Same File
Switch back to main branch:
git checkout main
Modify app.js:
echo 'console.log("Hello from main branch - modified");' > app.js
Commit the changes:
git add app.js
git commit -m "Updated app.js in main"
Now, app.js is different in both main and feature-branch.
Merge feature-branch into main, Try merging the feature-branch:
git merge feature-branch
Git Conflict Detected!
You’ll see:
warning: Cannot merge binary files: app.js (HEAD vs. feature-branch)
Auto-merging app.js
CONFLICT (content): Merge conflict in app.js
Automatic merge failed; fix conflicts and then commit the result..

Check the Conflict
git status
On branch main
….Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   app.js
…..
Open app.js and you’ll see: (VS Code provides an intuitive interface to compare and resolve conflicts.)
Resolve the Conflict
Now, manually edit app.js and keep the correct version:
Final app.js (Resolved)
console.log("Hello from main branch - modified");
console.log("Hello from feature branch");
Mark Conflict as Resolved

Now, stage the file:
git add app.js
Commit the merge:
git commit -m "Resolved merge conflict in app.js"
Conflict is now resolved!

Verify Merge History
Check the log:
git log --oneline --graph --all > aa.txt
This confirms the successful merge.

Alternative: Abort the Merge
If you want to cancel and undo the merge, run:
git merge --abort
This resets the repository back to before the merge.







git commit --amend (Amending the Last Commit)
Steps to Amend the Last Commit:
1. Create and Commit feature.js:
echo "console.log('Initial commit');" > feature.js
git add feature.js
git commit -m "Initial commit with feature.js"
Modify the Commit Message or Content: 
Let's say we realize that the commit message is incorrect or we forgot to add some changes. We want to amend it.
Modify the files you want to change.
For example, edit a file or add new content:
echo "console.log('Updated feature')" >> feature.js
2. Stage the changes:
git add feature.js
3. Amend the last commit:
To set Visual Studio Code (VS Code) as your default Git editor, you can use the following command:
git config --global core.editor "code --wait"
Open amend of commit in VS code
git commit --amend
This will open your default text editor, allowing you to change the commit message if needed. The changes you made will now be part of the amended commit.
If you just want to change the commit message (without modifying the content), you can use:
git commit --amend --no-edit
The --no-edit flag keeps the commit message unchanged.
4. Push the changes (if the commit has already been pushed to a remote): 
If you've already pushed the original commit, you'll need to force push:
Dont run this:
git push --force
Be careful when force-pushing to shared repositories, as this can overwrite history for others.








1. Create Multiple Commits: First, we’ll create three commits to practice rebase:
echo "console.log('Commit 1');" > feature.js
git add feature.js
git commit -m "Commit 1"

echo "console.log('Commit 2');" >> feature.js
git add feature.js
git commit -m "Commit 2"

echo "console.log('Commit 3');" >> feature.js
git add feature.js
git commit -m "Commit 3"

2. Check the status to identify the unstaged changes:
git status
This will show any modified or untracked files that need to be addressed before proceeding.
Stash the changes (if you don't want to commit them yet): If you want to temporarily save the changes and proceed with the rebase, you can stash them:
git stash
This will store your changes temporarily and leave your working directory clean.
Proceed with the Interactive Rebase: 
Once your working directory is clean, you can proceed with the interactive rebase:
git rebase -i HEAD~3

3. Edit the Commit List: Your default editor will open with a list of commits:
pick 1a2b3c4 Commit message 1
pick 5d6e7f8 Commit message 2
pick 9a0b1c2 Commit message 3


You can change the command next to each commit:
pick: Keep the commit as is.
reword: Change the commit message.
edit: Amend the commit (useful for changing files).
squash: Combine this commit with the previous one.
fixup: Similar to squash, but discards the commit message.
drop: Remove the commit.


For example, to squash the last two commits into one:
pick 1a2b3c4 Commit message 1
squash 5d6e7f8 Commit message 2
pick 9a0b1c2 Commit message 3

4. Save and Exit: 
After making your changes, save and exit the editor (for example, in Vim, press Esc, type :wq, and hit Enter).
5. Resolve Conflicts (If Any): 
Resolve any conflicts (if necessary): If there are conflicts during the rebase, Git will prompt you to resolve them. 
After resolving conflicts, use:
git rebase --continue
If there are conflicts during the rebase, Git will stop and allow you to resolve them. 
After fixing the conflicts, stage the changes:
git add <file>
Then, continue the rebase:
git rebase --continue
6. Apply the Stashed Changes (if you stashed them): After completing the rebase, you can apply your stashed changes:
git stash pop
7. Force Push (If Needed): 
If you've already pushed your changes, you may need to force push the rewritten history:
git push --force








Sometimes, you may accidentally lose a commit or move the branch reference to an unintended commit. 
git reflog allows you to view and recover these lost commits.
Steps to Recover Lost Commits:
1. Create Commits:
Create the first commit
echo "console.log('Initial commit');" > feature1.js
git add feature1.js
git commit -m "Initial commit"
Create a second commit
echo "console.log('Second commit');" >> feature1.js
git add feature1.js
git commit -m "Second commit"
Create a third commit
echo "console.log('Third commit');" >> feature1.js
git add feature1.js
git commit -m "Third commit"

2. View the Commit History
Before we simulate a lost commit, let's check the commit history:
git log --oneline
Output (example commit hashes will differ):
3024c8a (HEAD -> main) Third commit
631218a Second commit
8a9a2ce Initial commit
…
3. Delete (Lose) the Latest Commit
Now, let’s assume we mistakenly reset to an earlier commit, losing the latest commit.
git reset --hard HEAD~1
HEAD is now at 631218a Second commit
This will remove the latest commit (Third commit) from the history.
Check the commit log again:
git log --oneline
Output:
631218a (HEAD -> main) Second commit
8a9a2ce Initial commit
..
The "Third commit" is gone from the history!

Steps to Recover Lost Commits:
4. View the Reflog: Recover the Lost Commit using git reflog
At this point, Git still tracks where HEAD has moved in the past, and we can use git reflog to find the lost commit.
The git reflog command shows the history of changes to the HEAD reference, including commits that were removed, rebased, or reset.
git reflog
Output (example commit hashes will differ):
631218a (HEAD -> main) HEAD@{0}: reset: moving to HEAD~1
3024c8a HEAD@{1}: commit: Third commit
631218a (HEAD -> main) HEAD@{2}: commit: Second commit
8a9a2ce HEAD@{3}: commit: Initial commit 
..
The commit 3024c8a (Third commit) is still accessible via reflog.
5. Find the Commit: 
Look through the reflog output for the commit you want to recover. 
Note the commit hash (e.g., 3024c8a).
6. To restore it, simply run:
git reset --hard 3024c8a
HEAD is now at 3024c8a Third commit

7. Verify the Recovery
Check the log again:
git log --oneline
Output:
3024c8a (HEAD -> main) Third commit
631218a Second commit
8a9a2ce Initial commit 
..
The "Third commit" has been recovered successfully!






